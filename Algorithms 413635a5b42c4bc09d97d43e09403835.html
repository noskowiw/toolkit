<html><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><title>Algorithms</title><link href="style.css" rel="stylesheet"/></head><body><article class="page sans" id="413635a5-b42c-4bc0-9d97-d43e09403835"><header><figure class="image" id="327caa5a-07b8-498f-bca9-097a8a9505ce"><svg fill="none" height="240" viewbox="0 0 1278 1278" width="240" xmlns="http://www.w3.org/2000/svg"><path d="M863.974 1004.06H414.997C414.997 1004.06 378.602 1004.38 361.503 983.558C347.462 966.458 346 947.403 346 947.403V329.713C346 329.713 353.339 299.013 367.003 286.058C382.48 271.384 414.997 273.058 414.997 273.058H863.974C863.974 273.058 897.606 276.567 914.503 296.558C928.786 313.455 931 329.713 931 329.713V947.403C931 947.403 931 966.058 908.5 984.058C883.5 1004.06 863.974 1004.06 863.974 1004.06Z" stroke="#75D573" stroke-linejoin="round" stroke-width="60"></path><path d="M500.004 417.059L763.004 417.059" stroke="#75D573" stroke-linecap="round" stroke-linejoin="round" stroke-width="60"></path><path d="M632.004 581.059L787.004 581.059" stroke="#75D573" stroke-linecap="round" stroke-linejoin="round" stroke-width="60"></path><path d="M632.004 711.059L787.004 711.059" stroke="#75D573" stroke-linecap="round" stroke-linejoin="round" stroke-width="60"></path><path d="M632.004 839.059L787.004 839.059" stroke="#75D573" stroke-linecap="round" stroke-linejoin="round" stroke-width="60"></path><circle cx="493.004" cy="581.059" fill="#75D573" r="30"></circle><circle cx="493.004" cy="711.059" fill="#75D573" r="30"></circle><circle cx="493.004" cy="839.059" fill="#75D573" r="30"></circle></svg></figure><h1 class="page-title">Algorithms</h1><p class="page-description"></p></header><div class="page-body"><p class="" id="c4d10986-427a-48bc-a571-c5d94ce45a68">date:</p><p class="" id="194653ba-fcbe-4bfd-ab3f-97fb6c6f3f2c">author: Wojciech Noskowiak</p><p class="" id="0a0df472-2694-4401-b36e-84b9584d6c5f">
</p><p class="" id="e070c43a-0fa4-4086-885e-9e091051a485">almost every problem in programming has more than one potential solution. </p><ul class="bulleted-list" id="15525da3-2567-4691-94fd-d7c3f8e97f6d"><li style="list-style-type:disc">choosing the right algorithm or a data structure is the most significant part of making your program energy efficient </li></ul><ul class="bulleted-list" id="cfec1cc1-2c81-4ff7-9bb7-e568d6129b67"><li style="list-style-type:disc">you should always find a right algorithm for the task at hand</li></ul><ul class="bulleted-list" id="18f280ad-827e-47c0-9e80-16fe7d40aa98"><li style="list-style-type:disc">implementing them is not always straightforward and can possibly cause errors. in some smaller contexts / less resource intensive fragments of the application implementing them might not be worth the hassle. </li></ul><ul class="bulleted-list" id="d5258c55-fada-4f56-b329-674bac7caed0"><li style="list-style-type:disc">However if a certain fragment of the codebase is being run very frequently a significant amount of attention should be utilized in order to make it as algorithmically sound as possible</li></ul><ul class="bulleted-list" id="14855958-f2cc-41f7-9ad7-1f608ad96888"><li style="list-style-type:disc">finding the right algorithm or a data structure for the job is rarely a trivial task.  There is a large body of resources out there that can help you out. the best way to find out which approach might work best for your specific scenario is to look for a well documented best solution to a similar or analogous problem  </li></ul><ul class="bulleted-list" id="74f660d8-9047-4941-81fc-3a8a8ce30ae4"><li style="list-style-type:disc">Practically all algorithms and data structures you can possibly used have been implemented is some way or another in every programming language. There’s probably no need for you to write anything from scratch (eg. c++ standard library provides ready made implementations for almost every commonly used algorithm and data structure out there)</li></ul><p class="" id="63f0f260-b09d-492b-847f-aed08d4f812f">
</p><p class="" id="5fca64f5-c71e-410c-9709-184ea2a756c8">
</p><p class="" id="82f55a87-34c0-4f9f-a730-6f880848baec">
</p><p class="" id="43bb771d-a990-4bb2-a740-00ff0acb76b3">Almost every problem in programming has more than one functionally solution. Although all of them can most likely deliver the same correct output their energy efficiency and time of execution can vary widely. In cloud computing where resources can be scaled at will some inefficiencies can be addressed by provisioning more resources. This however causes a significantly decreases in energy efficiency, making this solution unsustainable </p><p class="" id="e448f420-6a6f-4d4b-bbb3-11bda315d774">
</p><p class="" id="d5aeddb6-9016-419c-8c77-10c8d722937e">In this case the difference between an efficient and an inefficient solution is the algorithms and data structures used to make it. Choosing the appropriate algorithm or data structure for the task at hand is crucial for making your program energy efficient. However incorporating them into an existing codebase might not always be straightforward and may cause errors to appear.</p><p class="" id="2f5c255d-7c31-4f1e-ada5-6de965feb5e6">
</p><p class="" id="25b00338-2a10-4d15-bcfc-c942af6c90c2">Moreover, finding the right algorithm or data structure for the job is rarely a trivial task. It requires careful consideration of the specific requirements and constraints of the problem at hand. The problem's structure, size, and complexity have to be thoroughly analyzed before choosing a specific algorithm to apply. </p><p class="" id="02cb7064-1b94-4f4c-9564-3e3a45be29b8">
</p><p class="" id="79aee4d6-a0d1-45cf-b2c2-0ee569f2dbe0">It is worth noting that for smaller contexts or less resource-intensive fragments of the application, implementing complex algorithms might not be worth the hassle. However, any frequently run fragment of code should be made as algorithmically sound as possible.</p><p class="" id="013633ca-01eb-4870-b3d5-2d718e4f3099">
</p><p class="" id="5656424f-8666-4200-916b-3b07ab190091">finding the right algorithm or a data structure for the job is rarely a trivial task.  There is a large body of resources out there that can help you out. the best way to find out which approach might work best for your specific scenario is to look for a well documented best solution to a similar or analogous problem  </p><p class="" id="d6fc0bed-c677-460e-ba73-b6145ff5155a">
</p><p class="" id="52f8cf11-64e3-47d5-8bc3-bcf7d2d0d1c9">Practically all algorithms and data structures you can possibly used have been implemented is some way or another in every programming language. There’s probably no need for you to write anything from scratch (eg. c++ standard library provides ready made implementations for almost every commonly used algorithm and data structure out there)</p><p class="" id="9b57bd81-fcf9-41d3-81f7-25e9ff70d259">
</p><p class="" id="c25c3639-85b5-44ad-8962-83cd61c1d71e">further reading:</p><p class="" id="eeb53ad6-81ec-4057-b0ce-49bcacf9218e"><a href="https://dl.ebooksworld.ir/books/Introduction.to.Algorithms.4th.Leiserson.Stein.Rivest.Cormen.MIT.Press.9780262046305.EBooksWorld.ir.pdf">https://dl.ebooksworld.ir/books/Introduction.to.Algorithms.4th.Leiserson.Stein.Rivest.Cormen.MIT.Press.9780262046305.EBooksWorld.ir.pdf</a></p><p class="" id="9ab0f15b-6d50-4e52-80e4-82de9a7e3526">
</p></div></article></body></html>