<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Algorithms</title><link rel="stylesheet" href="style.css">
</head><body><article id="413635a5-b42c-4bc0-9d97-d43e09403835" class="page sans"><header><p class="page-description"></p></header><div class="page-body"><p id="c4d10986-427a-48bc-a571-c5d94ce45a68" class="">date:</p><p id="194653ba-fcbe-4bfd-ab3f-97fb6c6f3f2c" class="">author: Wojciech Noskowiak</p><p id="0a0df472-2694-4401-b36e-84b9584d6c5f" class="">
</p><p id="e070c43a-0fa4-4086-885e-9e091051a485" class="">almost every problem in programming has more than one potential solution. </p><ul id="15525da3-2567-4691-94fd-d7c3f8e97f6d" class="bulleted-list"><li style="list-style-type:disc">choosing the right algorithm or a data structure is the most significant part of making your program energy efficient </li></ul><ul id="cfec1cc1-2c81-4ff7-9bb7-e568d6129b67" class="bulleted-list"><li style="list-style-type:disc">you should always find a right algorithm for the task at hand</li></ul><ul id="18f280ad-827e-47c0-9e80-16fe7d40aa98" class="bulleted-list"><li style="list-style-type:disc">implementing them is not always straightforward and can possibly cause errors. in some smaller contexts / less resource intensive fragments of the application implementing them might not be worth the hassle. </li></ul><ul id="d5258c55-fada-4f56-b329-674bac7caed0" class="bulleted-list"><li style="list-style-type:disc">However if a certain fragment of the codebase is being run very frequently a significant amount of attention should be utilized in order to make it as algorithmically sound as possible</li></ul><ul id="14855958-f2cc-41f7-9ad7-1f608ad96888" class="bulleted-list"><li style="list-style-type:disc">finding the right algorithm or a data structure for the job is rarely a trivial task.  There is a large body of resources out there that can help you out. the best way to find out which approach might work best for your specific scenario is to look for a well documented best solution to a similar or analogous problem  </li></ul><ul id="74f660d8-9047-4941-81fc-3a8a8ce30ae4" class="bulleted-list"><li style="list-style-type:disc">Practically all algorithms and data structures you can possibly used have been implemented is some way or another in every programming language. There’s probably no need for you to write anything from scratch (eg. c++ standard library provides ready made implementations for almost every commonly used algorithm and data structure out there)</li></ul><p id="63f0f260-b09d-492b-847f-aed08d4f812f" class="">
</p><p id="5fca64f5-c71e-410c-9709-184ea2a756c8" class="">
</p><p id="82f55a87-34c0-4f9f-a730-6f880848baec" class="">
</p><p id="43bb771d-a990-4bb2-a740-00ff0acb76b3" class="">Almost every problem in programming has more than one functionally solution. Although all of them can most likely deliver the same correct output their energy efficiency and time of execution can vary widely. In cloud computing where resources can be scaled at will some inefficiencies can be addressed by provisioning more resources. This however causes a significantly decreases in energy efficiency, making this solution unsustainable </p><p id="e448f420-6a6f-4d4b-bbb3-11bda315d774" class="">
</p><p id="d5aeddb6-9016-419c-8c77-10c8d722937e" class="">In this case the difference between an efficient and an inefficient solution is the algorithms and data structures used to make it. Choosing the appropriate algorithm or data structure for the task at hand is crucial for making your program energy efficient. However incorporating them into an existing codebase might not always be straightforward and may cause errors to appear.</p><p id="2f5c255d-7c31-4f1e-ada5-6de965feb5e6" class="">
</p><p id="25b00338-2a10-4d15-bcfc-c942af6c90c2" class="">Moreover, finding the right algorithm or data structure for the job is rarely a trivial task. It requires careful consideration of the specific requirements and constraints of the problem at hand. The problem&#x27;s structure, size, and complexity have to be thoroughly analyzed before choosing a specific algorithm to apply. </p><p id="02cb7064-1b94-4f4c-9564-3e3a45be29b8" class="">
</p><p id="79aee4d6-a0d1-45cf-b2c2-0ee569f2dbe0" class="">It is worth noting that for smaller contexts or less resource-intensive fragments of the application, implementing complex algorithms might not be worth the hassle. However, any frequently run fragment of code should be made as algorithmically sound as possible.</p><p id="013633ca-01eb-4870-b3d5-2d718e4f3099" class="">
</p><p id="5656424f-8666-4200-916b-3b07ab190091" class="">finding the right algorithm or a data structure for the job is rarely a trivial task.  There is a large body of resources out there that can help you out. the best way to find out which approach might work best for your specific scenario is to look for a well documented best solution to a similar or analogous problem  </p><p id="d6fc0bed-c677-460e-ba73-b6145ff5155a" class="">
</p><p id="52f8cf11-64e3-47d5-8bc3-bcf7d2d0d1c9" class="">Practically all algorithms and data structures you can possibly used have been implemented is some way or another in every programming language. There’s probably no need for you to write anything from scratch (eg. c++ standard library provides ready made implementations for almost every commonly used algorithm and data structure out there)</p><p id="9b57bd81-fcf9-41d3-81f7-25e9ff70d259" class="">
</p><p id="c25c3639-85b5-44ad-8962-83cd61c1d71e" class="">further reading:</p><p id="eeb53ad6-81ec-4057-b0ce-49bcacf9218e" class=""><a href="https://dl.ebooksworld.ir/books/Introduction.to.Algorithms.4th.Leiserson.Stein.Rivest.Cormen.MIT.Press.9780262046305.EBooksWorld.ir.pdf">https://dl.ebooksworld.ir/books/Introduction.to.Algorithms.4th.Leiserson.Stein.Rivest.Cormen.MIT.Press.9780262046305.EBooksWorld.ir.pdf</a></p><p id="9ab0f15b-6d50-4e52-80e4-82de9a7e3526" class="">
</p></div></article></body></html>